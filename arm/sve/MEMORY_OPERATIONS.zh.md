# SVE 内存操作：基础指南

Arm 可伸缩向量扩展（SVE）提供了强大的指令集，用于在内存和可伸缩向量寄存器之间移动数据。理解这些操作是编写高效 SIMD 代码的关键。本指南旨在解释 SVE 中可用的基本内存访问模式。

所有 SVE 指令都由一个谓词（`svbool_t`）控制。只有在谓词中为 `true` 的向量通道才会参与内存访问。

## 1. 核心访问模式

在 SIMD 中，主要有两种内存访问方式：

- **连续访问 (Consecutive/Contiguous Access)：** 这是最简单、最常见的模式。它涉及从内存中读取或向内存写入一个完整、无间断的数据块。可以将其想象为顺序读取一个数组。这通常是性能最高的访问方法。

- **非连续访问 (Non-Consecutive Access)：** 此模式涉及读取或写入分散在内存中不同位置的数据元素。这对于更复杂的算法至关重要，例如查找表、处理稀疏数据或操作特定的数据结构。

## 2. SVE 加载与存储指令

`load_instructions_s32.cpp` 和 `store_instructions_u32.cpp` 中的示例演示了这些模式。

### 2.1. 连续访问: `svld1` & `svst1`

- **概念：** 这些是用于简单内存访问的主力指令。`svld1` 将一个连续的数据块加载到一个向量中，而 `svst1` 将向量的内容存储到一个连续的块中。
- **应用场景：** 非常适合处理简单的数组、缓冲区以及任何在内存中顺序布局的数据。

### 2.2. 非连续访问 (收集/分散): `svld1_gather` & `svst1_scatter`

- **概念：** SVE 提供了“收集”（gather）加载指令从分散的位置读取数据，以及“分散”（scatter）存储指令向这些位置写入数据。这通过提供一个包含地址或索引的向量来实现。
- **变体：**
    - **基于偏移量 (`_offset_`)：** 提供一个基地址和一个*字节偏移量*向量。每个通道的最终地址是 `base + offset_vector[lane]`。
    - **基于索引 (`_index_`)：** 提供一个基地址和一个*元素索引*向量。硬件会自动将索引乘以元素大小（例如 `sizeof(int32_t)`）。最终地址是 `base + index_vector[lane] * element_size`。这通常比手动计算字节偏移量更方便。
- **应用场景：** 访问结构体成员、实现查找表，或处理任何数据元素在内存中不相邻的算法。

### 2.3. 交错访问: `svld2`/`svst2`

- **概念：** 这些指令是为*交错*数据设计的一种特殊形式的连续访问。`svld2` 从一个交错的数据流（例如 `R1, G1, R2, G2, ...`）中读取，并将其解交错到两个独立的向量中（一个用于 `R`，一个用于 `G`）。`svst2` 则执行相反的操作。SVE 还提供了用于3通道和4通道数据的 `svld3` 和 `svld4`。
- **应用场景：** 非常适合处理多通道数据，如 RGB/RGBA 图像、立体声音频或复数。

### 2.4. 特殊的缓存控制和故障处理加载

- **概念：** SVE 包含一些指令，让程序员能更好地控制缓存和错误处理。
- **非临时性 (`svldnt1`, `svstnt1`)：** 此指令向 CPU 提供一个提示，表明正在加载或存储的数据是“非临时性的”（即，短期内不会被重复使用）。这可以防止这些数据替换掉缓存中更重要、更常用的数据，这种现象被称为“缓存污染”。这是针对流式操作的一种性能优化。
- **首次故障 (`svldff1`)：** 这种加载在遇到第一个无效的内存访问时会停止。谓词寄存器会被更新，以显示在故障发生前哪些通道已成功加载。这对于安全地遍历未知长度的数据结构（如C风格字符串）非常有用。
- **非故障 (`svldnf1`)：** 这种加载在遇到无效内存访问时*不会*导致程序崩溃。相反，它会在目标向量中将相应的通道置零，并更新谓词。

---

**后续步骤：** 尽管 SVE 提供了一套功能强大且全面的内存操作指令，但其后续版本 **SVE2** 在此基础上进行了扩展，增加了更多专用且功能更强的指令，特别是增强了非连续数据访问的能力。