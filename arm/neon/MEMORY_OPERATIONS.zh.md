# 理解NEON的加载与存储操作

高效地在内存和NEON寄存器之间移动数据是SIMD编程的基础。NEON为此提供了一套丰富的内建函数（intrinsics）。掌握这些函数的关键在于识别其命名约定中的一致性模式。

所有加载和存储内建函数都遵循一个通用结构：

`v[ld|st][N]q?_[lane?]_[type]_[xM]`

-   **`v`**: 所有NEON内建函数的标准前缀。
-   **`ld` 或 `st`**: 指定操作类型：从内存**加载**（load）或向内存**存储**（store）。
-   **`[N]`**: 数字（2, 3, 或 4），指示要进行解交错（de-interleave）或交错（interleave）操作的向量数量。如果此部分不存在，则表示对单个向量结构的常规操作。
-   **`q`**: 可选标志。如果存在，表示这是一个128位的操作（例如 `uint8x16_t`）。如果不存在，则是64位的操作（例如 `uint8x8_t`）。
-   **`_lane`**: 可选修饰符，表示操作的目标是向量中的单个通道（lane）。
-   **`_dup`**: (仅用于加载) 可选修饰符，表示加载单个值并将其复制（duplicate）到向量的所有通道中。
-   **`_[type]`**: 正在处理的数据类型（例如 `u8`, `f32`, `s16`）。
-   **`_xM`**: (仅用于 `vld1`/`vst1`) 可选后缀，表示多向量操作，连续加载或存储 `M` 个完整的向量。

---

## 核心概念与示例

以下是内存操作的主要模式。理解这些模式将使您能够解读几乎所有的加载/存储内建函数。

### 1. 基本加载/存储 (`vld1` / `vst1`)

这是最常见的操作。它从一个连续的内存块中加载一个完整向量的数据，或将一个完整的向量存回内存。

-   **`vld1q_u8`**: 从内存加载16个 `uint8_t` 值到一个 `uint8x16_t` 寄存器中。
-   **`vst1q_u8`**: 将一个 `uint8x16_t` 寄存器中的16个 `uint8_t` 值存储到内存中。

**使用场景**: 对数组和数据缓冲区进行标准处理。

### 2. 加载并复制 (`vld1_dup`)

此操作从内存加载*单个*元素，并将其广播（复制）到目标向量的每个通道。

-   **`vld1q_dup_u8`**: 读取一个 `uint8_t` 值，并创建一个 `uint8x16_t` 向量，其中所有16个通道都包含该值。

**使用场景**: 为算术运算准备一个常量值（例如，将整个向量乘以一个从内存加载的数）。

### 3. 加载/存储单个通道 (`vld1_lane` / `vst1_lane`)

此操作从内存读取单个值到一个*已存在*向量的特定通道中，或者将向量中的单个通道存储到内存中。

-   **`vld1q_lane_u8`**: 加载一个 `uint8_t` 值到一个 `uint8x16_t` 向量的指定通道，而不影响其他15个通道。
-   **`vst1q_lane_u8`**: 将 `uint8x16_t` 向量中的一个通道的值存储到一个 `uint8_t` 的内存地址。

**使用场景**: 将分散的数据收集到一个向量中，或将计算结果分散存回到不连续的内存位置。

### 4. 解交错加载 / 交错存储 (`vldN` / `vstN`)

这些是处理结构化数据（如多通道图像RGB, RGBA）的强大指令。

-   **`vld3q_u8`**: 从一个交错的内存缓冲区（例如 `R1, G1, B1, R2, G2, B2, ...`）读取数据，并将其分离到三个独立的 `uint8x16_t` 向量中：一个用于所有R值，一个用于所有G值，一个用于所有B值。
-   **`vst3q_u8`**: 执行相反的操作，将三个独立的向量（R, G, B）以交错格式写回内存。

**使用场景**: 处理多通道数据的核心操作。它允许您对每个通道独立执行操作（例如，仅调整R通道的亮度），然后再将它们合并回去。

### 5. 多向量加载/存储 (`vld1_xM` / `vst1_xM`)

这是一个简单的批量操作。它从一个连续的内存块中加载或存储多个*完整*的向量。

-   **`vld1q_u8_x2`**: 从内存中加载32个字节到两个独立的 `uint8x16_t` 向量中。
-   **`vst1q_u8_x2`**: 将两个 `uint8x16_t` 向量存储到一个连续的32字节内存块中。

**使用场景**: 当您需要同时对多个向量进行操作时，用于加载或存储更大数据块。

**关键区别**: 不要将 `vld2q_u8` (解交错) 与 `vld1q_u8_x2` (多向量加载) 混淆。`vld2` 将 `A1, B1, A2, B2, ...` 分离成两个向量 `{A...}` 和 `{B...}`。而 `vld1_x2` 只是从一个连续的内存块中加载 `{A1..A16}` 和 `{B1..B16}`。
